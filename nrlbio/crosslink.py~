"""API for handling crosslink. Can be used in different applications
Constants:
	AWARD collections.OrderedDict: fixed award/penalty for T->C conversions. Key is tuple of positions of crosslink, relative to seed start. Value is integer value of award/penalty
	NEGMULT int: fixed penalty for having a "T" notconverted. Penalty is an AWARD value corresponding to a postion multiplied by NEGMULT
"""
from math import log
from collections import OrderedDict

AWARD = OrderedDict()
AWARD[(-1,)] = log(6);
AWARD[(-2,)] = log(3.8);
AWARD[(-6,)] = log(3.3);
AWARD[(-3,7,8,9)] = log(1.7);
AWARD[(0,1,2,3,4,5)] = log(0.2);
NEGMULT = -0.5;



def assess_crosslink(maf, pcp, position, award, negmult):
	"""assess the credibility of binding site according to crosslink relative postion
	
	maf conservation.Maf: Maf object represents region of potential binding, with additional information about conservation 
	pcp pybedtools.Interval: represents the same region as "maf" attribute, with additional information about crosslink
	position int: start of seed site inside the region
	award collections.OrderedDict: award/penalty for T->C conversions. Key is tuple of positions of crosslink, relative to seed start. Value is integer value of award/penalty
	negmult int: penalty for having a "T" not converted. Penalty is an AWARD value corresponding to a postion multiplied by NEGMULT 
	
	Returns float: credibility of binding site according to crosslink relative postion
	"""	
	if(maf.strand == '+'):
		cr = int(pcp.attrs['ccr']) - pcp.start - 1;	#ccr in pcp is 1-based, so we have to adjust to 0-based
	else:
		cr =  pcp.end - int(pcp.attrs['ccr']);
	relseed = cr - position	
	
	for k, v in award.items():
		if relseed in k:
			return v;
	else:
		for k, v in award.items()[:-1]:
			for p in k:
				pinseq = p+position;
				if(pinseq and pinseq<len(maf.refseq) and maf.refseq[position+p] == "T"):
					return v*negmult;
	return 0.0;