# /usr/bin/python
'''creates new seq_record based on features and description for partial seq_record on basis of complete sequence'''

import argparse
import sys;
import os;
import datetime
from collections import defaultdict, Counter;

from Bio.SeqFeature import FeatureLocation, CompoundLocation, SeqFeature
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO




parser = argparse.ArgumentParser(description='creates new seq_record based on features and description for partial seq_record on basis of complete sequence');
parser.add_argument('-r', '--record', nargs = '?', required = True, type = str, help = "path to genbank record");
parser.add_argument('-f', '--fasta', nargs = '?', required = True, type = str, help = "path to the fasta file with complete sequence");
parser.add_argument('--output', nargs = '?', required = True, type = str, help = "path to the new genbank record with added features");
parser.add_argument('-o', '--offset', nargs = '?', required = True, type = int, help = "adjustment value, which will be added to start and end boundaries of the feature")
parser.add_argument('--id', nargs = '?', required = True, type = str, help = "id of new record");
parser.add_argument('--name', nargs = '?', required = True, type = str, help = "name of new record");
args = parser.parse_args();

def adjust_location(location, offset):
	if(type(location) == CompoundLocation):
		parts = [FeatureLocation(x.start + offset, x.end + offset, strand=x.strand) for x in location.parts];
		return CompoundLocation(parts, operator = location.operator)
	elif(type(location) == FeatureLocation):
		return FeatureLocation(location.start + offset, location.end + offset, strand=location.strand)
	else:
		raise Exception('unrecognized type of location\n')


sequence = SeqIO.read(args.fasta, 'fasta').seq;
seq_record = SeqIO.read(args.record, 'genbank')
sequence.alphabet = seq_record.seq.alphabet;


not_transferable_annotations = ['accessions', 'keywords', 'date', 'comment']
annotations = dict([x for x in seq_record.annotations.items() if x[0] not in not_transferable_annotations])
annotations['comment'] = "Record %s full sequence.\nThe record was generated by partial2complete.py script.\nIt is constructed from partial record: %s\nand complete sequence: %s." % (args.name, os.path.basename(args.record), os.path.basename(args.fasta))
annotations['date'] = datetime.date.today().isoformat();
annotations['accessions'] = ["no accesions"];
annotations['keywords'] = [];


seq_record.seq = sequence;
seq_record.annotations = annotations
seq_record.id = args.id
seq_record.name = args.name
seq_record.description = "%s complete sequence" % args.name
for feature in seq_record.features:
	if(feature.type == 'source'):
		feature.location = FeatureLocation(0, len(seq_record), strand=feature.location.strand)
	else:	
		feature.location = adjust_location(feature.location, args.offset)

SeqIO.write([seq_record], args.output, "genbank");

#old = SeqIO.read(args.record, 'genbank');
#new = SeqIO.read(args.output, 'genbank')

#for f1, f2 in zip(old.features[1:], new.features[1:]):
	#if(str(f1.extract(old).seq) != str(f2.extract(new).seq)):
		##print f1
		#print str(f1.extract(old))
		#print "*"*150
		##print f2
		#print str(f2.extract(new))
		#print "_"*150
	#else:
		#pass
		
		
